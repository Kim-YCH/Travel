<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å‡ºç™¼å›‰ (v48 é™¤éŒ¯ç‰ˆ)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.prod.js" crossorigin="anonymous"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: sans-serif; background: #f0f2f5; padding-bottom: 250px; /* ç•™ç©ºé–“çµ¦é™¤éŒ¯æ¡† */ }
        .card { background: white; border-radius: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); padding: 15px; margin-bottom: 10px; }
        .flex { display: flex; } .gap-2 { gap: 8px; }
        input, select { border: 1px solid #ddd; padding: 8px; border-radius: 4px; width: 100%; }
        
        /* åœ°åœ–å®¹å™¨ */
        #map { height: 300px; width: 100%; background: #eee; margin-top: 10px; }
        
        /* æœå°‹å»ºè­° */
        .suggestions-list { position: absolute; top: 100%; left: 0; right: 0; background: white; z-index: 50; max-height: 250px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .suggestion-item { padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; }
        .suggestion-item:hover { background: #f0f9ff; }

        /* é™¤éŒ¯è¦–çª— (å›ºå®šåœ¨åº•éƒ¨ï¼Œä¿è­‰å¯è¦‹) */
        #debug-console {
            position: fixed; bottom: 0; left: 0; right: 0; height: 200px;
            background: #000; color: #0f0; font-family: monospace; font-size: 12px;
            padding: 10px; overflow-y: scroll; z-index: 99999; opacity: 0.95;
            border-top: 2px solid #fff;
        }
        .log-err { color: #ff5555; font-weight: bold; border-bottom: 1px solid #ff5555; }
    </style>
</head>
<body>

<div id="debug-console">
    <div>=== v48.0 ç³»çµ±æ—¥èªŒ ===</div>
</div>

<script>
    // å¼·åˆ¶æ””æˆªéŒ¯èª¤
    function log(msg, type='info') {
        const el = document.getElementById('debug-console');
        const line = document.createElement('div');
        line.innerText = '> ' + msg;
        if(type === 'error') line.className = 'log-err';
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
        console.log(msg);
    }
    window.onerror = function(msg, url, line, col, error) {
        log("âŒ å…¨å±€éŒ¯èª¤: " + msg + " (Line: " + line + ")", 'error');
        if(error) log("Stack: " + error.stack, 'error');
        return false;
    };
    log("HTML è¼‰å…¥å®Œæˆï¼Œæº–å‚™å•Ÿå‹• Vue...");
</script>

<div id="app">
    <div style="padding: 20px; text-align: center; color: red;">
        Vue å°šæœªæ›è¼‰ (å¦‚æœçœ‹åˆ°é€™è¡Œå­—ä¸”ä¸‹é¢æ²’æ±è¥¿ï¼Œä»£è¡¨ Vue å•Ÿå‹•å¤±æ•—)
    </div>

    <div v-if="isLoading" style="position:fixed;top:0;left:0;right:0;height:4px;background:blue;z-index:999;"></div>

    <div v-if="currentView === 'lobby'" class="p-4">
        <h1 class="text-3xl font-bold mb-4">âœˆï¸ å‡ºç™¼å›‰</h1>
        
        <div class="space-y-4 mb-8">
            <div v-for="trip in trips" :key="trip.id" @click="selectTrip(trip)" class="card cursor-pointer border-l-4 border-blue-500 hover:shadow-md flex justify-between">
                <div><div class="font-bold text-xl">{{ trip.name }}</div><div class="text-sm text-gray-500">{{ trip.city }}</div></div><div>âœ</div>
            </div>
            <div v-if="trips.length === 0" class="text-center text-gray-400 py-10">
                <span v-if="isLoading">è®€å–ä¸­...</span>
                <span v-else>å°šç„¡æ—…ç¨‹</span>
            </div>
        </div>

        <div class="card">
            <h3 class="font-bold mb-2">æ–°å¢æ—…ç¨‹</h3>
            <input v-model="newTripName" placeholder="æ—…ç¨‹åç¨±" class="mb-2">
            <input v-model="newTripCity" placeholder="ä¸»è¦åŸå¸‚" class="mb-2">
            <button @click="createTrip" class="w-full bg-blue-600 text-white py-2 rounded font-bold" :disabled="isLoading">å»ºç«‹</button>
        </div>
    </div>

    <div v-else class="flex flex-col h-full">
        <header class="bg-blue-600 text-white p-4 pt-8 sticky top-0 z-50 flex justify-between items-center">
            <div><h1 class="text-lg font-bold">{{ currentTrip ? currentTrip.name : 'è¼‰å…¥ä¸­...' }}</h1><div class="text-xs">Day {{ currentDay }}</div></div>
            <button @click="fetchData" class="text-xs bg-blue-800 px-3 py-1 rounded">â†» åŒæ­¥</button>
        </header>

        <main class="flex-1 overflow-hidden flex flex-col p-4 overflow-y-auto">
            <div v-if="currentTab === 'itinerary'" class="space-y-4">
                <div class="flex gap-2 overflow-x-auto">
                    <button v-for="d in totalDays" :key="d" @click="currentDay = d" class="px-4 py-1 rounded-full border text-sm" :class="currentDay === d ? 'bg-blue-600 text-white' : 'bg-white text-gray-500'">Day {{ d }}</button>
                    <button @click="addNewDay" class="px-3 py-1 rounded-full border bg-white">+</button>
                </div>
                
                <div class="card relative">
                    <div class="flex gap-2 mb-2 relative">
                        <input v-model="newPlace" @input="searchPlacesInput" type="text" placeholder="æœå°‹åœ°é»..." class="flex-1">
                        <button @click="addPlace" class="bg-blue-600 text-white w-10 rounded">+</button>
                        <div v-if="searchResults.length > 0" class="suggestions-list">
                            <div v-for="item in searchResults" :key="item.place_id" @click="selectPlace(item)" class="suggestion-item">
                                ğŸ“ {{ item.structured_formatting.main_text }}
                            </div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <input v-model="newTime" type="time" class="w-1/3">
                        <input v-model="newNote" type="text" placeholder="å‚™è¨»..." class="flex-1">
                    </div>
                </div>
                
                <div class="space-y-3">
                    <div v-for="place in filteredItinerary" :key="place.id" class="card flex justify-between items-start">
                        <div class="flex-1" @click="openGoogleMap(place)">
                            <div class="flex items-center gap-2">
                                <span v-if="place.time" class="text-blue-600 font-bold text-sm bg-blue-50 px-1 rounded">{{ formatTime(place.time) }}</span>
                                <span class="font-bold text-lg">{{ place.name }}</span>
                            </div>
                            <div v-if="place.message" class="text-sm text-gray-500">ğŸ“ {{ place.message }}</div>
                        </div>
                        <div>
                            <button @click.stop="editPlace(place)" class="text-gray-400 px-1">âœ</button>
                            <button @click.stop="removePlace(place.id)" class="text-red-400 px-1">Ã—</button>
                        </div>
                    </div>
                </div>
            </div>

            <div v-show="currentTab === 'map'" class="h-full flex flex-col">
                <button @click="fitBoundsToTrip" class="bg-white text-blue-600 p-2 rounded shadow mb-2 text-sm font-bold border">ğŸ”„ é¡¯ç¤ºæ‰€æœ‰è¡Œç¨‹</button>
                <div id="map"></div>
                <div v-if="!isMapReady" class="text-center text-gray-500 p-4">åœ°åœ–è¼‰å…¥ä¸­...</div>
            </div>

            <div v-if="currentTab === 'money'" class="space-y-4">
                <div class="card bg-gray-800 text-white">
                    <div class="flex justify-between items-end"><span class="text-gray-400">ç¸½æ”¯å‡º</span><span class="text-2xl font-bold">${{ totalExpense }}</span></div>
                    <div class="border-t border-gray-600 mt-2 pt-2 text-sm"><div v-for="res in balanceSheet" :key="res.name" class="flex justify-between"><span>{{ res.name }}</span><span>{{ res.balance }}</span></div></div>
                </div>
                <div class="card">
                    <div class="flex gap-2 mb-2"><input v-model="newExpense.title" placeholder="é …ç›®" class="flex-1"><input v-model.number="newExpense.amount" type="number" placeholder="$" class="w-20"></div>
                    <div class="flex gap-2 mb-2"><button v-for="cat in categories" :key="cat" @click="newExpense.category = cat" class="px-2 py-1 text-xs rounded border" :class="newExpense.category===cat?'bg-blue-500 text-white':''">{{cat}}</button></div>
                    <select v-model="newExpense.payer" class="mb-2 w-full"><option v-for="p in people" :value="p.name">{{p.name}}</option></select>
                    <button @click="addExpense" class="w-full bg-blue-600 text-white py-2 rounded">è¨˜å¸³</button>
                </div>
                <div v-for="exp in expenses" :key="exp.id" class="card flex justify-between">
                    <div><div class="font-bold">{{ exp.title }}</div><div class="text-xs text-gray-500">{{ exp.payer }} ä»˜æ¬¾</div></div>
                    <div class="font-bold">${{ exp.amount }} <button @click="removeExpense(exp.id)" class="text-red-400 ml-2">Ã—</button></div>
                </div>
            </div>

            <div v-if="currentTab === 'settings'" class="p-4 space-y-4">
                <button @click="exitTrip" class="w-full bg-gray-600 text-white py-2 rounded mb-4">ğŸ”™ åˆ‡æ›æ—…ç¨‹</button>
                <button @click="exportItinerary" class="w-full border border-blue-500 text-blue-500 py-2 rounded">ğŸ“¤ åŒ¯å‡ºè¡Œç¨‹</button>
                
                <h3 class="font-bold mt-4">æˆå“¡ç®¡ç†</h3>
                <div class="flex gap-2"><input v-model="newPerson" placeholder="åå­—"><button @click="addPerson" class="bg-gray-800 text-white px-4 rounded">æ–°å¢</button></div>
                <div v-for="p in people" :key="p.id" class="flex justify-between p-2 border-b"><span>{{p.name}}</span><button @click="removePerson(p.id)" class="text-red-500">ç§»é™¤</button></div>
            </div>
        </main>

        <nav class="bg-white border-t flex justify-around p-2 pb-6">
            <button @click="switchTab('itinerary')" class="text-2xl">ğŸ“</button>
            <button @click="switchTab('map')" class="text-2xl">ğŸ—ºï¸</button>
            <button @click="switchTab('money')" class="text-2xl">ğŸ’°</button>
            <button @click="switchTab('settings')" class="text-2xl">âš™ï¸</button>
        </nav>
    </div>
</div>

<script>
    const { createApp, ref, computed, onMounted, nextTick } = Vue;
    log("Vue æ ¸å¿ƒè¼‰å…¥å®Œæˆ");

    const app = createApp({
        setup() {
            log("Vue Setup é–‹å§‹åŸ·è¡Œ...");
            
            // â˜… Config â˜…
            const API_URL = 'https://script.google.com/macros/s/AKfycby303KH-yL7YZajdYUwBQEW-lyFmhz5qsCL5KrY73fZSS5wmSfjPZX8qCYxaNP3FnM/exec';
            const GOOGLE_MAPS_API_KEY = 'AIzaSyCLrHk9V-eQby0aDVx31iwFyqmhI-jIs4Q';

            // State
            const currentView = ref('lobby'); const currentTrip = ref(null); const trips = ref([]); 
            const newTripName = ref(''); const newTripCity = ref('');
            const currentTab = ref('itinerary'); const isLoading = ref(false); 
            const isMapLoading = ref(false); const isMapReady = ref(false);
            const currentDay = ref(1); const totalDays = ref(1);
            
            const people = ref([]); const itinerary = ref([]); const expenses = ref([]);
            const newPlace = ref(''); const newTime = ref(''); const newNote = ref(''); const newPerson = ref('');
            const newExpense = ref({ title: '', amount: '', payer: '', involved: [], category: 'é£²é£Ÿ' });
            const categories = ['é£²é£Ÿ', 'äº¤é€š', 'ä½å®¿', 'è³¼ç‰©', 'é–€ç¥¨'];
            const searchResults = ref([]);
            
            // Map
            let mapInstance = null; let markers = []; let autocompleteService = null; let infoWindow = null;

            const generateId = () => Date.now() + '_' + Math.floor(Math.random() * 1000);
            
            // Time Format - Protect against null/undefined
            const formatTime = (timeStr) => {
                if (!timeStr) return '';
                if (typeof timeStr === 'string' && /^\d{1,2}:\d{2}$/.test(timeStr)) return timeStr;
                try {
                    const date = new Date(timeStr);
                    if (isNaN(date.getTime())) return timeStr;
                    return `${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
                } catch { return timeStr; }
            };

            const loadGoogleMaps = () => {
                if (window.google) {
                    isMapReady.value = true;
                    return;
                }
                log("æ­£åœ¨è¼‰å…¥ Google Maps...");
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=places&language=zh-TW`;
                script.async = true; script.defer = true;
                script.onload = () => { 
                    log("Google Maps è¼‰å…¥æˆåŠŸ");
                    try { autocompleteService = new google.maps.places.AutocompleteService(); } catch(e){ log("Autocomplete åˆå§‹åŒ–å¤±æ•—: " + e, 'error'); }
                    isMapReady.value = true;
                };
                script.onerror = () => log("âŒ Google Maps è¼‰å…¥å¤±æ•—ï¼", 'error');
                document.head.appendChild(script);
            };

            const fetchTrips = async () => {
                log("æ­£åœ¨è®€å–æ—…ç¨‹åˆ—è¡¨...");
                isLoading.value = true;
                try {
                    const res = await fetch(`${API_URL}?type=trips`);
                    const data = await res.json();
                    log("æ—…ç¨‹åˆ—è¡¨è®€å–æˆåŠŸ: " + data.length + " ç­†");
                    trips.value = data;
                } catch (e) { log("âŒ è®€å–æ—…ç¨‹å¤±æ•—: " + e, 'error'); }
                finally { isLoading.value = false; }
            };

            const createTrip = async () => {
                if (!newTripName.value) return;
                isLoading.value = true;
                const id = generateId();
                const newTrip = { id, name: newTripName.value, city: newTripCity.value };
                trips.value.push(newTrip);
                newTripName.value = '';
                await fetch(API_URL, { method: 'POST', body: JSON.stringify({ action: 'add', type: 'trips', data: newTrip }) });
                isLoading.value = false;
            };

            const selectTrip = (trip) => {
                log("é¸æ“‡æ—…ç¨‹: " + trip.name);
                currentTrip.value = trip;
                itinerary.value = []; expenses.value = []; people.value = [];
                currentView.value = 'app';
                fetchData();
            };

            const fetchData = async () => {
                if (!currentTrip.value) return;
                isLoading.value = true;
                const tid = currentTrip.value.id;
                try {
                    log("æ­£åœ¨è®€å–è©³ç´°è³‡æ–™...");
                    const [resItin, resExp, resPpl] = await Promise.all([
                        fetch(`${API_URL}?type=itinerary&tripId=${tid}`),
                        fetch(`${API_URL}?type=expenses&tripId=${tid}`),
                        fetch(`${API_URL}?type=people&tripId=${tid}`)
                    ]);
                    itinerary.value = await resItin.json();
                    expenses.value = await resExp.json();
                    people.value = await resPpl.json();
                    if(people.value.length) newExpense.value.payer = people.value[0].name;
                    
                    if (itinerary.value.length > 0) {
                        const max = itinerary.value.reduce((m, i) => Math.max(m, parseInt(i.day||1)), 1);
                        totalDays.value = max;
                    }
                    log("è©³ç´°è³‡æ–™è®€å–å®Œæˆ");
                } catch(e) { log("âŒ è©³ç´°è³‡æ–™è®€å–å¤±æ•—: " + e, 'error'); }
                finally { isLoading.value = false; }
            };

            // Search
            const searchPlacesInput = () => {
                if (!newPlace.value || !autocompleteService) return;
                autocompleteService.getPlacePredictions({ input: newPlace.value }, (predictions, status) => {
                    if (status === google.maps.places.PlacesServiceStatus.OK) searchResults.value = predictions;
                });
            };

            const selectPlace = (item) => {
                newPlace.value = item.structured_formatting.main_text;
                addPlace(item.place_id); 
                searchResults.value = [];
            };

            const addPlace = async (googlePlaceId = null) => {
                if(!newPlace.value) return;
                const id = generateId();
                const item = { 
                    id, name: newPlace.value, day: currentDay.value, 
                    time: newTime.value, message: newNote.value,
                    lat: '', lng: '', place_id: googlePlaceId 
                };
                
                log("æ–°å¢åœ°é»: " + item.name);
                itinerary.value.push(item); // å…ˆé¡¯ç¤º
                newPlace.value = ''; newNote.value = '';

                if (googlePlaceId && window.google) {
                    const dummy = document.createElement('div');
                    const service = new google.maps.places.PlacesService(dummy);
                    service.getDetails({ placeId: googlePlaceId }, (place, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK) {
                            item.lat = place.geometry.location.lat();
                            item.lng = place.geometry.location.lng();
                            log(`å–å¾—åº§æ¨™: ${item.lat}, ${item.lng}`);
                            sendToApi('add', 'itinerary', item);
                        } else {
                            sendToApi('add', 'itinerary', item);
                        }
                    });
                } else {
                    sendToApi('add', 'itinerary', item);
                }
            };

            const removePlace = (id) => {
                const idx = itinerary.value.findIndex(i => i.id === id);
                if (idx > -1) {
                    itinerary.value.splice(idx, 1);
                    sendToApi('del', 'itinerary', id);
                }
            };
            
            const editPlace = (item) => {
                newPlace.value = item.name;
                newTime.value = formatTime(item.time);
                newNote.value = item.message;
                removePlace(item.id);
            };

            const sendToApi = async (action, type, data) => {
                const body = { action, type };
                if (action === 'add') {
                    data.trip_id = currentTrip.value.id;
                    body.data = data;
                } else {
                    body.id = data;
                }
                fetch(API_URL, { method: 'POST', body: JSON.stringify(body) }).catch(e => log("âŒ å„²å­˜å¤±æ•—: " + e, 'error'));
            };

            // Map Logic
            const switchTab = (tab) => {
                currentTab.value = tab;
                if (tab === 'map') {
                    nextTick(() => {
                        setTimeout(() => {
                            if (!mapInstance && window.google) {
                                log("åˆå§‹åŒ–åœ°åœ–...");
                                mapInstance = new google.maps.Map(document.getElementById('map'), {
                                    center: { lat: 23.6, lng: 121 }, zoom: 8, streetViewControl: false
                                });
                                infoWindow = new google.maps.InfoWindow();
                            }
                            if(mapInstance) {
                                google.maps.event.trigger(mapInstance, 'resize');
                                updateMapMarkers();
                            }
                        }, 200);
                    });
                }
            };

            const updateMapMarkers = () => {
                if (!mapInstance) return;
                markers.forEach(m => m.setMap(null)); markers = [];
                const bounds = new google.maps.LatLngBounds();
                let hasPoint = false;

                itinerary.value.forEach(item => {
                    if (item.lat && item.lng) {
                        const pos = { lat: parseFloat(item.lat), lng: parseFloat(item.lng) };
                        const marker = new google.maps.Marker({
                            position: pos, map: mapInstance, label: item.day.toString(), title: item.name
                        });
                        
                        marker.addListener("click", () => {
                            infoWindow.setContent(`<div style="color:black;padding:5px;"><b>${item.name}</b><br>${item.message||''}</div>`);
                            infoWindow.open(mapInstance, marker);
                        });

                        markers.push(marker);
                        bounds.extend(pos);
                        hasPoint = true;
                    }
                });
                
                if (hasPoint) mapInstance.fitBounds(bounds);
            };
            
            const fitBoundsToTrip = () => updateMapMarkers();
            
            const openGoogleMap = (p) => {
                if (p.place_id) window.open(`https://www.google.com/maps/place/?q=place_id:${p.place_id}`, '_blank');
                else if (p.lat) window.open(`https://www.google.com/maps/search/?api=1&query=${p.lat},${p.lng}`, '_blank');
                else window.open(`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(p.name)}`, '_blank');
            };

            // Other
            const addNewDay = () => { totalDays.value++; currentDay.value = totalDays.value; };
            const addExpense = async () => { 
                if(!newExpense.value.title || !newExpense.value.amount) return;
                const id = generateId();
                const item = { id, ...newExpense.value, involved: people.value.map(p=>p.name) };
                expenses.value.unshift(item);
                newExpense.value.title = ''; newExpense.value.amount = '';
                await sendToApi('add', 'expenses', { ...item, involved: item.involved.join(',') });
            };
            const removeExpense = (idx) => { 
                const item = expenses.value[idx];
                expenses.value.splice(idx, 1);
                sendToApi('del', 'expenses', item.id);
            };
            const addPerson = async () => { 
                if(!newPerson.value) return;
                const id = generateId();
                const p = { id, name: newPerson.value };
                people.value.push(p); newPerson.value = '';
                await sendToApi('add', 'people', p);
            };
            const removePerson = (idx) => {
                const p = people.value[idx];
                if(confirm('ç¢ºå®šç§»é™¤?')) {
                    people.value.splice(idx, 1);
                    sendToApi('del', 'people', p.id);
                }
            };
            const exportItinerary = () => {
                let txt = `ã€${currentTrip.value.name}ã€‘\n`;
                itinerary.value.sort((a,b) => (a.day - b.day) || (a.time||'').localeCompare(b.time||'')).forEach(i => {
                    txt += `D${i.day} ${formatTime(i.time)} ${i.name}\n`;
                });
                navigator.clipboard.writeText(txt).then(() => alert("å·²è¤‡è£½"));
            };
            const resetTrip = async () => { if(confirm('æ¸…ç©º?')) await fetch(API_URL, {method:'POST', body:JSON.stringify({action:'reset_trip', type:'all', tripId: currentTrip.value.id})}); location.reload(); };
            const exitTrip = () => { currentView.value = 'lobby'; currentTrip.value = null; fetchTrips(); };

            onMounted(() => {
                fetchTrips();
                loadGoogleMaps();
            });

            return {
                currentView, trips, newTripName, newTripCity, createTrip, selectTrip, exitTrip,
                currentTab, switchTab, isLoading, currentTrip, currentDay, totalDays, addNewDay,
                itinerary, expenses, people,
                newPlace, newTime, newNote, searchResults, searchPlacesInput, selectPlace,
                addPlace, removePlace, editPlace, openGoogleMap,
                newExpense, categories, addExpense, removeExpense,
                newPerson, addPerson, removePerson,
                fetchData, formatTime, fitBoundsToTrip,
                filteredItinerary: computed(() => itinerary.value.filter(i => parseInt(i.day) == currentDay.value).sort((a,b)=>(a.time||'').localeCompare(b.time||''))),
                balanceSheet: computed(() => {
                    let b={}; people.value.forEach(p=>b[p.name]=0);
                    expenses.value.forEach(e=>{
                        const amt=Number(e.amount);
                        if(b[e.payer]!==undefined) b[e.payer]+=amt;
                        const len = e.involved.length || people.value.length;
                        const share = amt/len;
                        (e.involved.length?e.involved:people.value.map(p=>p.name)).forEach(n=> { if(b[n]!==undefined) b[n]-=share; });
                    });
                    return Object.keys(b).map(n=>({name:n, balance: Math.round(b[n])}));
                }),
                totalExpense: computed(() => expenses.value.reduce((s,i)=>s+(Number(i.amount)||0),0)),
                categoryAnalysis: computed(() => {
                    const s={}; expenses.value.forEach(e=>{ s[e.category] = (s[e.category]||0)+Number(e.amount); });
                    return Object.keys(s).map(k=>({name:k, total:s[k]}));
                }),
                exportItinerary, resetTrip, isMapLoading, isMapReady
            };
        }
    });

    app.mount('#app');
    log("Vue æ›è¼‰æŒ‡ä»¤å·²ç™¼å‡º");
</script>
</body>
</html>
